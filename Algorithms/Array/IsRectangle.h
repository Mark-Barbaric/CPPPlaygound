// Type your code here, or load an example.
#define _USE_MATH_DEFINES
#include <iostream>
#include <vector>
#include <cmath>
#include <string>
#include <optional>
#include <math.h>
/*

Context
=======

This question is based on a real problem that we had to solve in production. There was a computationally
expensive algorithm implemented for generic polygons; however we have noticed that in the majority of
cases the polygon that we were passing to the algorithm was a rectangle, and for rectangles the
implementation of the algorithm was much faster.

Task
====

Implement a function that determines whether a given `Polygon` represents an axis-aligned rectangle, and
if so, returns a `Rectangle` which is equivalent.

You may assume:

- `Polygon` is a counter-clockwise oriented collection of points. This means the inside of the polygonpolygon8
   would be on your left if you walked around the boundary following the points in the order provided
- `Polygon`, if not empty, is guaranteed to be cyclic, that is `polygon.front() == polygon.back()`

The `Polygon` may have been generated by other algorithms which suffer numerical instability problems so
your implementation should aim to be robust to degenerate cases. Example degenerate cases which should
be handled include:

- Points lying on the straight edge connecting another pair of points a.k.a. redundant points
- Polygons with points slightly perturbed from exact rectangles should still convert to rectangles

Instructions
============

- Write one or two paragraphs about the chosen approach and document key assumptions you make regarding
  the input and the expected behaviour of your implementation
- Preserve the API of the `fit_into_rectangle` function (so we can easily run it through a test suite)
- Submit your solution as a single .cpp file and provide the compilation command used to build it.
  If you have been asked to submit your solution using codeinterview.io, you can make sure that your
  solution builds and passes the tests by pressing the "Run" button at the bottom of the page
- Please give an approximate time taken to solve the question

Small Note
===============

I noticed during testing that it looks the epsilon value which is being passed from almost_equal method from line 119
isn't being passed to the almost_equal method from line 105, so the method from line 105 always takes the default value.
I wasn't sure if this was intentional, so I changed this during my tests, but commented it out as part of the submission.

Chosen Approach
===============

Satisfaction criteria for a Polygon to be an axis-aligned rectangle are below:

1. Must have four sides and four "corners".
2. Each "corner" must be a right angle.
3. The top and bottom sides must be aligned to x-axis and left and right sides must be aligned to y-axis.
5. Parallel sides are equal in distance but adjacent sides are not equal in distance*.

Assumptions:

1. Rectangle position is allowed to deviate from axis by a window of "epsilon" to account for perturbed points.
2. Passed polygon traverses in an anti-clockwise fashion, meaning that the change in angle for each corner
will be + 90 degrees, (unless going from 270 to 0).

Approach

My approach involved traversing the Polygon to determine the angle between each points, as well as the change in angle
direction. The first step involves calculating the angle between the first two points in the Polygon. If this angle was not a
modulus of 90 degrees*, then the object is not axis-aligned. The next step involved iterating over each point in the Polygon to
identify any + 90 degree changes in angle direction, in order to populate a list integers representing the location of each
90 degree "corner" in the Polygon. If an angle change was not +90 degrees or the polygon didn't have 4 right angles, then the
Polygon could not be an anti-clockwise axis aligned Rectangle,so std::nullopt is returned. This leaves only leaves a Rectangle
or Square, so the corner positions were used to compare the parallel and adjacent side distances to make sure that the
Polygon was not a Square.

* Given that the requirement that axis position can deviate by "epsilon", the expected angle was allow to deviate from 90 degree
by a factor of atan(2.0f * epsilon) * 180.0f / M_PI
** Given the requirement that axis position can deviate by "epsilon", allowed calculated distance for adjancent and parallel sides
to deviate by 2.0f * epsilon.
*/

constexpr float k_default_epsilon = .0001f;

bool almost_equal(float a, float b, float epsilon = k_default_epsilon) {
    return std::abs(a - b) <= epsilon;
}

struct Point {
    float x;
    float y;
    friend bool operator==(const Point& lhs, const Point& rhs) {
        return lhs.x == rhs.x and lhs.y == rhs.y;
    }
    friend std::ostream& operator<<(std::ostream& out, const Point& point) {
        return out << "(" << point.x << "," << point.y << ")";
    }
};

bool almost_equal(const Point& a, const Point& b, float epsilon = k_default_epsilon) {
    return almost_equal(a.x, b.x, epsilon) and almost_equal(a.y, b.y, epsilon);
}

using Polygon = std::vector<Point>;

struct Rectangle {
    Point bottom_left;
    Point top_right;
    friend std::ostream& operator<<(std::ostream& out, const Rectangle& rectangle) {
        return out << "Rectangle(" << rectangle.bottom_left << "," << rectangle.top_right << ")";
    }
};

bool almost_equal(const Rectangle& a, const Rectangle& b, float epsilon = k_default_epsilon) {
    return almost_equal(a.bottom_left, b.bottom_left /*,epsilon*/)
    and almost_equal(a.top_right, b.top_right /*,epsilon*/);
}

float angle_between_points(const Point& p1, const Point& p2){
    const float delta_x = p2.x - p1.x;
    const float delta_y = p2.y - p1.y;
    auto angle =  static_cast<float>(atan2(delta_y, delta_x) * 180.0f / M_PI);

    if(angle < 0.0f){
        angle += 360.0f;
    }

    return angle;
}

float distance_between_points(const Point& p1, const Point& p2){
    return std::powf(std::powf(p1.y - p2.y, 2.0f) +
    std::powf(p1.x - p2.x, 2.0f), 0.5f);
}

bool are_distances_almost_equal(const Point& p1, const Point& p2,
                                const Point& p3, const Point& p4, float epsilon){
    return std::fabs(distance_between_points(p1, p2) - distance_between_points(p3, p4)) <= (epsilon * 2.0f);
}

bool are_parallel_sides_equal(const std::vector<int>& corners, const Polygon& polygon, float epsilon){
    return are_distances_almost_equal(polygon[corners[0]], polygon[corners[1]],polygon[corners[2]], polygon[corners[3]], epsilon) &&
    are_distances_almost_equal(polygon[corners[1]], polygon[corners[2]],polygon[corners[0]], polygon[corners[3]], epsilon);
}

bool are_adjacent_sides_equal(const std::vector<int>& corners, const Polygon& polygon, float epsilon){
    return are_distances_almost_equal(polygon[corners[0]], polygon[corners[1]], polygon[corners[0]], polygon[corners[3]], epsilon) &&
    are_distances_almost_equal(polygon[corners[1]], polygon[corners[2]], polygon[corners[2]], polygon[corners[3]], epsilon);
}

bool are_angles_anti_clockwise(float prev_angle, float new_angle,
                               float angle_margin){

    // need to account for 270 to 0 changes
    if(std::fabs(new_angle - 0.0f) <= angle_margin && std::fabs(prev_angle - 270.0f) <= angle_margin){
        return true;
    }

    if(std::fabs(new_angle - prev_angle - 90.0f) <= angle_margin){
        return true;
    }

    return false;
}

// TODO Implement this function
std::optional<Rectangle> fit_into_rectangle(const Polygon& polygon, float epsilon = k_default_epsilon) {

    std::vector<int> corners;
    corners.reserve(4);
    const float angle_margin = atan(epsilon) * 180.0f / M_PI;
    auto prev_angle = angle_between_points(polygon[0], polygon[1]);

    if(fmod(prev_angle,90.0f) > angle_margin){
        return std::nullopt;
    }

    Point bottom_left = polygon[0].x <= polygon[1].x &&
            polygon[0].y <= polygon[1].y ? polygon[0] : polygon[1];
    Point top_right = polygon[0].x >= polygon[1].x &&
            polygon[0].y >= polygon[1].y ? polygon[0] : polygon[1];

    for(int i = 2; i < polygon.size(); ++i){
        const auto new_angle = angle_between_points(polygon[i - 1], polygon[i]);

        if(std::fabs(new_angle - prev_angle) >= angle_margin){

            if(!are_angles_anti_clockwise(prev_angle, new_angle, angle_margin)){
                return std::nullopt;
            }

            if(corners.size() == 4){
                return std::nullopt;
            }

            if(polygon[i - 1].x <= bottom_left.x && polygon[i - 1].y <= bottom_left.y){
                bottom_left = polygon[i - 1];
            }

            if(polygon[i - 1].x >= top_right.x && polygon[i - 1].y >= top_right.y){
                top_right = polygon[i - 1];
            }

            corners.emplace_back(i - 1);
            prev_angle = new_angle;
        }
    }

    if(corners.size() == 2){
        return std::nullopt;
    }

    // first point was a corner
    if(corners.size() == 3){
        corners.emplace_back(0);
    }

    // square
    if(!are_parallel_sides_equal(corners, polygon, epsilon) ||
    are_adjacent_sides_equal(corners, polygon, epsilon)){
        return std::nullopt;

    }

    return {{bottom_left, top_right}};
}

